<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calligraphy Art</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="artwork-container">
        <!-- Add SVG filters and paper texture -->
        <svg width="0" height="0">
            <defs>
                <!-- Noise filter for paper texture -->
                <filter id="paper-texture" x="0%" y="0%" width="100%" height="100%">
                    <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="5" result="noise" />
                    <feDiffuseLighting in="noise" lighting-color="#938976" surfaceScale="2">
                        <feDistantLight azimuth="45" elevation="60" />
                    </feDiffuseLighting>
                </filter>

                <!-- Shadow filter for flourishes -->
                <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur" />
                    <feOffset in="blur" dx="2" dy="2" result="offsetBlur" />
                    <feMerge>
                        <feMergeNode in="offsetBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>

                <!-- Grain texture -->
                <filter id="grain">
                    <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch" />
                    <feColorMatrix type="saturate" values="0" />
                </filter>
            </defs>
        </svg>

        <!-- Paper texture overlay -->
        <svg class="paper-texture" viewBox="0 0 800 600" preserveAspectRatio="none">
            <!-- Base texture -->
            <rect width="100%" height="100%" filter="url(#paper-texture)" />

            <!-- Grain overlay -->
            <rect width="100%" height="100%" filter="url(#grain)" opacity="0.1" />

            <!-- Subtle stains -->
            <circle cx="20%" cy="30%" r="100" fill="#938976" opacity="0.03" />
            <circle cx="80%" cy="70%" r="120" fill="#8b7355" opacity="0.02" />
            <ellipse cx="50%" cy="40%" rx="200" ry="150" fill="#826644" opacity="0.015" />
        </svg>

        <svg class="ornamental-frame" viewBox="0 0 800 600">
            <path
                d="M 50,50 C 150,30 650,30 750,50 C 770,150 770,450 750,550 C 650,570 150,570 50,550 C 30,450 30,150 50,50 Z"
                class="flourish-path" />
        </svg>

        <div class="text-wrapper">
            <div class="text-line">
                <span class="first-letter"></span>
                <span class="middle-letters"></span>
                <span class="last-letter"></span>
            </div>
            <div class="ornament-container">
                <svg class="text-flourish" viewBox="0 0 400 120">
                    <!-- Main flourish -->
                    <path d="M 50,20 
                            C 100,40 150,0 200,20 
                            S 300,40 350,20" class="flourish-path" />

                    <!-- Lower flourish -->
                    <path d="M 30,40 
                            C 80,60 150,20 200,40 
                            S 320,60 370,40" class="flourish-path" />

                    <!-- Decorative swirls -->
                    <path d="M 180,30 
                            C 190,20 200,20 200,30 
                            S 210,40 220,30" class="flourish-path" />

                    <!-- Left side ornament -->
                    <path d="M 50,30 
                            C 40,20 30,20 20,30 
                            Q 10,40 20,50 
                            C 30,60 40,60 50,50" class="flourish-path" />

                    <!-- Right side ornament -->
                    <path d="M 350,30 
                            C 360,20 370,20 380,30 
                            Q 390,40 380,50 
                            C 370,60 360,60 350,50" class="flourish-path" />

                    <!-- Small dots -->
                    <circle cx="200" cy="60" r="2" fill="#800020" />
                    <circle cx="180" cy="65" r="2" fill="#800020" />
                    <circle cx="220" cy="65" r="2" fill="#800020" />
                </svg>
            </div>
        </div>

        <div class="decorative-dots">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>

        <!-- Add input container -->
        <div class="input-container">
            <input type="text" class="text-input" placeholder="Type your text here..." value="Bugra" maxlength="20">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const textInput = document.querySelector('.text-input');
            const firstLetterSpan = document.querySelector('.first-letter');
            const middleLettersSpan = document.querySelector('.middle-letters');
            const lastLetterSpan = document.querySelector('.last-letter');
            const flourishContainer = document.querySelector('.text-flourish');

            // Set initial placeholder text
            const initialText = textInput.value || 'Bugra';
            firstLetterSpan.textContent = initialText[0];
            if (initialText.length > 1) {
                middleLettersSpan.textContent = initialText.substring(1, initialText.length - 1);
                lastLetterSpan.textContent = initialText[initialText.length - 1];
            }

            // Function to update text and flourish size
            function updateText(value) {
                if (!value) value = 'Bugra';

                // Split the text to apply different fonts
                if (value.length > 1) {
                    firstLetterSpan.textContent = value[0]; // First letter
                    middleLettersSpan.textContent = value.substring(1, value.length - 1); // Middle letters
                    lastLetterSpan.textContent = value[value.length - 1]; // Last letter
                } else {
                    // If only one character, it's both first and last
                    firstLetterSpan.textContent = value;
                    middleLettersSpan.textContent = '';
                    lastLetterSpan.textContent = '';
                }

                // Wait for the DOM to update with the new text
                requestAnimationFrame(() => {
                    // Get the new text width (combined width of all spans)
                    const width = firstLetterSpan.offsetWidth +
                        middleLettersSpan.offsetWidth +
                        lastLetterSpan.offsetWidth;

                    // Calculate new viewBox width based on text length
                    const baseWidth = 400;
                    const minWidth = 300;
                    const charWidth = 50; // Approximate width per character
                    const newWidth = Math.max(minWidth, baseWidth + (value.length * charWidth));

                    // Update SVG viewBox
                    flourishContainer.setAttribute('viewBox', `0 0 ${newWidth} 120`);

                    // Scale flourish paths based on text width
                    const paths = flourishContainer.querySelectorAll('path');
                    const scale = width / baseWidth;

                    paths.forEach(path => {
                        // Update path coordinates based on new width
                        const d = path.getAttribute('d');
                        const scaledD = scalePathData(d, scale);
                        path.setAttribute('d', scaledD);
                    });

                    // Update dots position
                    const dots = flourishContainer.querySelectorAll('circle');
                    dots.forEach((dot, index) => {
                        const baseX = 180 + (index * 20);
                        dot.setAttribute('cx', baseX * scale);
                    });
                });
            }

            // Helper function to scale SVG path data
            function scalePathData(d, scale) {
                return d.replace(/[-0-9.]+/g, (match) => {
                    const num = parseFloat(match);
                    return (num * scale).toFixed(2);
                });
            }

            // Add input event listener
            textInput.addEventListener('input', (e) => {
                updateText(e.target.value);
            });

            // Initialize with default text
            updateText(textInput.value);
        });
    </script>
</body>

</html>