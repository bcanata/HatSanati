<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calligraphy Art</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="artwork-container">
        <!-- Add SVG filters and paper texture -->
        <svg width="0" height="0">
            <defs>
                <!-- Noise filter for paper texture -->
                <filter id="paper-texture" x="0%" y="0%" width="100%" height="100%">
                    <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="5" result="noise" />
                    <feDiffuseLighting in="noise" lighting-color="#938976" surfaceScale="2">
                        <feDistantLight azimuth="45" elevation="60" />
                    </feDiffuseLighting>
                </filter>

                <!-- Shadow filter for flourishes -->
                <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur" />
                    <feOffset in="blur" dx="2" dy="2" result="offsetBlur" />
                    <feMerge>
                        <feMergeNode in="offsetBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>

                <!-- Grain texture -->
                <filter id="grain">
                    <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch" />
                    <feColorMatrix type="saturate" values="0" />
                </filter>
            </defs>
        </svg>

        <!-- Paper texture overlay -->
        <svg class="paper-texture" viewBox="0 0 800 600" preserveAspectRatio="none">
            <!-- Base texture -->
            <rect width="100%" height="100%" filter="url(#paper-texture)" />

            <!-- Grain overlay -->
            <rect width="100%" height="100%" filter="url(#grain)" opacity="0.1" />

            <!-- Subtle stains -->
            <circle cx="20%" cy="30%" r="100" fill="#938976" opacity="0.03" />
            <circle cx="80%" cy="70%" r="120" fill="#8b7355" opacity="0.02" />
            <ellipse cx="50%" cy="40%" rx="200" ry="150" fill="#826644" opacity="0.015" />
        </svg>

        <svg class="ornamental-frame" viewBox="0 0 800 600">
            <path
                d="M 50,50 C 150,30 650,30 750,50 C 770,150 770,450 750,550 C 650,570 150,570 50,550 C 30,450 30,150 50,50 Z"
                class="flourish-path" />
        </svg>

        <!-- Ottoman frame ornaments -->
        <div class="inner-frame"></div>
        <div class="ottoman-ornament top-ornament"></div>
        <div class="ottoman-ornament bottom-ornament"></div>
        <div class="ottoman-ornament left-ornament"></div>
        <div class="ottoman-ornament right-ornament"></div>

        <!-- Corner SVGs -->
        <img src="./vectors/corner.svg" class="corner-svg top-left-corner" alt="Corner Ornament"
            style="filter: invert(40%) sepia(20%) saturate(1095%) hue-rotate(358deg) brightness(89%) contrast(96%) drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));">
        <img src="./vectors/corner.svg" class="corner-svg top-right-corner" alt="Corner Ornament"
            style="filter: invert(40%) sepia(20%) saturate(1095%) hue-rotate(358deg) brightness(89%) contrast(96%) drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));">
        <img src="./vectors/corner.svg" class="corner-svg bottom-left-corner" alt="Corner Ornament"
            style="filter: invert(40%) sepia(20%) saturate(1095%) hue-rotate(358deg) brightness(89%) contrast(96%) drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));">
        <img src="./vectors/corner.svg" class="corner-svg bottom-right-corner" alt="Corner Ornament"
            style="filter: invert(40%) sepia(20%) saturate(1095%) hue-rotate(358deg) brightness(89%) contrast(96%) drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));">

        <div class="text-wrapper">
            <!-- Top decoration above text -->
            <img src="./vectors/top.svg" class="top-decoration" alt="Top Decoration"
                style="filter: invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%); opacity: 0.9;">

            <div class="text-line">
                <span class="first-letter"></span>
                <span class="middle-letters"></span>
                <span class="last-letter"></span>
            </div>
            <div class="ornament-container">
                <img class="ornament-vector" src="./vectors/shape1.svg" alt="Ornament">
            </div>
        </div>

        <!-- Add input container -->
        <div class="input-container">
            <button class="nav-button prev-button">&lt;</button>
            <input type="text" class="text-input" placeholder="Adınız / Your Name" value="Bugra" maxlength="20">
            <button class="nav-button next-button">&gt;</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const textInput = document.querySelector('.text-input');
            const firstLetterSpan = document.querySelector('.first-letter');
            const middleLettersSpan = document.querySelector('.middle-letters');
            const lastLetterSpan = document.querySelector('.last-letter');
            const ornamentVector = document.querySelector('.ornament-vector');
            const ornamentContainer = document.querySelector('.ornament-container');
            const prevButton = document.querySelector('.prev-button');
            const nextButton = document.querySelector('.next-button');

            // Apply gold filter to SVG elements immediately
            document.querySelectorAll('img[src$=".svg"]').forEach(img => {
                // Apply filter based on element class
                if (img.classList.contains('corner-svg')) {
                    // Keep corners with gold color
                    img.style.filter = "invert(40%) sepia(20%) saturate(1095%) hue-rotate(358deg) brightness(89%) contrast(96%) drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3))";
                } else {
                    // Apply brown color to other SVG elements
                    img.style.filter = "invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%)";
                    img.style.opacity = "0.9";
                }
            });

            // Special treatment for top decoration
            const topDecoration = document.querySelector('.top-decoration');
            if (topDecoration) {
                topDecoration.style.filter = "invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%)";
                topDecoration.style.opacity = "0.9";
            }

            // Set letter spacing for the text elements
            firstLetterSpan.style.letterSpacing = '-0.05em';
            middleLettersSpan.style.letterSpacing = '-0.05em';
            lastLetterSpan.style.letterSpacing = '-0.05em';

            // Set initial placeholder text
            const initialText = textInput.value || 'Bugra';
            updateText(initialText);

            // Function to update text and ornament
            function updateText(value) {
                if (!value) value = 'Bugra';

                // Split the text to apply different fonts
                if (value.length > 1) {
                    firstLetterSpan.textContent = value[0]; // First letter
                    middleLettersSpan.textContent = value.substring(1, value.length - 1); // Middle letters
                    lastLetterSpan.textContent = value[value.length - 1]; // Last letter

                    // Adjust font size based on text length
                    let fontSize = 6; // Default size in rem (increased from 5 to 6)
                    if (value.length > 7) {
                        fontSize = 6 - ((value.length - 7) * 0.3);
                        // Minimum font size
                        fontSize = Math.max(fontSize, 4.5); // Increased minimum size
                    }

                    firstLetterSpan.style.fontSize = `${fontSize}rem`;
                    middleLettersSpan.style.fontSize = `${fontSize}rem`;
                    lastLetterSpan.style.fontSize = `${fontSize}rem`;
                } else {
                    // If only one character, it's both first and last
                    firstLetterSpan.textContent = value;
                    middleLettersSpan.textContent = '';
                    lastLetterSpan.textContent = '';
                    firstLetterSpan.style.fontSize = '6rem'; // Increased from 5rem to 6rem
                }

                // Update ornament based on text length
                if (value.length >= 3) {
                    // Get current ornament index from counter or default to text-based selection
                    let currentOrnament = 1;

                    // Try to extract current ornament number from src attribute
                    const currentSrc = ornamentVector.src;
                    const match = currentSrc.match(/shape(\d+)\.svg/);
                    if (match && match[1]) {
                        currentOrnament = parseInt(match[1]);
                    } else {
                        currentOrnament = Math.min(value.length - 2, 7); // 1 for 3 chars, 2 for 4 chars, etc.
                    }

                    // Update ornament image
                    ornamentVector.src = `./vectors/shape${currentOrnament}.svg`;
                    ornamentVector.style.display = 'block';

                    // Apply the same color as the text instead of gold filter
                    ornamentVector.style.filter = "invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%)";
                    ornamentVector.style.opacity = "0.9";

                    // Adjust SVG size based on name length
                    let scaleFactor;

                    switch (value.length) {
                        case 3:
                            scaleFactor = 30; // Smaller
                            break;
                        case 4:
                            scaleFactor = 32;
                            break;
                        case 5:
                            scaleFactor = 35;
                            break;
                        case 6:
                            scaleFactor = 38;
                            break;
                        case 7:
                            scaleFactor = 40;
                            break;
                        case 8:
                            scaleFactor = 42;
                            break;
                        case 9:
                            scaleFactor = 45;
                            break;
                        default:
                            scaleFactor = 48; // For 10+ characters
                    }

                    ornamentVector.style.maxWidth = `${scaleFactor}%`;

                    // Update button states
                    prevButton.disabled = currentOrnament <= 1;
                    nextButton.disabled = currentOrnament >= 14;
                } else {
                    ornamentVector.style.display = 'none';
                }
            }

            // Add input event listener
            textInput.addEventListener('input', (e) => {
                // Reset ornament when text changes
                ornamentVector.src = './vectors/shape1.svg';

                // Apply the same color as the text
                ornamentVector.style.filter = "invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%)";
                ornamentVector.style.opacity = "0.9";

                updateText(e.target.value);
            });

            // Add ornament navigation event listeners
            prevButton.addEventListener('click', () => {
                // Extract current ornament number from src attribute
                const currentSrc = ornamentVector.src;
                const match = currentSrc.match(/shape(\d+)\.svg/);
                if (match && match[1]) {
                    const currentOrnament = parseInt(match[1]);
                    if (currentOrnament > 1) {
                        ornamentVector.src = `./vectors/shape${currentOrnament - 1}.svg`;
                        // Apply the same color as the text instead of gold filter
                        ornamentVector.style.filter = "invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%)";
                        ornamentVector.style.opacity = "0.9";
                        prevButton.disabled = currentOrnament - 1 <= 1;
                        nextButton.disabled = false;
                    }
                }
            });

            nextButton.addEventListener('click', () => {
                // Extract current ornament number from src attribute
                const currentSrc = ornamentVector.src;
                const match = currentSrc.match(/shape(\d+)\.svg/);
                if (match && match[1]) {
                    const currentOrnament = parseInt(match[1]);
                    if (currentOrnament < 14) {
                        ornamentVector.src = `./vectors/shape${currentOrnament + 1}.svg`;
                        // Apply the same color as the text instead of gold filter
                        ornamentVector.style.filter = "invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%)";
                        ornamentVector.style.opacity = "0.9";
                        nextButton.disabled = currentOrnament + 1 >= 14;
                        prevButton.disabled = false;
                    }
                }
            });

            // Hide ornament initially if text is less than 3 characters
            if (initialText.length < 3) {
                ornamentVector.style.display = 'none';
            } else {
                // Apply the same color as the text instead of gold filter
                ornamentVector.style.filter = "invert(22%) sepia(16%) saturate(1234%) hue-rotate(346deg) brightness(93%) contrast(95%)";
                ornamentVector.style.opacity = "0.9";
            }
        });
    </script>
</body>

</html>